{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"PGSync \u00b6 Postgres to Elasticsearch sync Documentation : https://pgsync.com Source Code : https://github.com/toluaina/pg-sync PGSync is a middleware for syncing data from Postgres to Elasticsearch. It allows you to keep Postgres as your source of truth data source and expose structured denormalized documents in Elasticsearch. Simply describe your document structure or schema in JSON and PGSync will continuously capture changes in your data and load it into Elasticsearch without writing any code. PGSync transforms your relational data into a structured document format. It allows you to take advantage of the expressive power and scalability of Elasticsearch directly from Postgres. You don\u2019t have to write complex queries and transformation pipelines. PGSync is lightweight, fast and flexible.","title":"PGSync"},{"location":"#pgsync","text":"Postgres to Elasticsearch sync Documentation : https://pgsync.com Source Code : https://github.com/toluaina/pg-sync PGSync is a middleware for syncing data from Postgres to Elasticsearch. It allows you to keep Postgres as your source of truth data source and expose structured denormalized documents in Elasticsearch. Simply describe your document structure or schema in JSON and PGSync will continuously capture changes in your data and load it into Elasticsearch without writing any code. PGSync transforms your relational data into a structured document format. It allows you to take advantage of the expressive power and scalability of Elasticsearch directly from Postgres. You don\u2019t have to write complex queries and transformation pipelines. PGSync is lightweight, fast and flexible.","title":"PGSync"},{"location":"advanced/re-indexing/","text":"Re-indexing involves: Deleting the Elasticsearch index curl -X DELETE <protocol>://<hostname>:<port>/<index> Delete the checkpoint file. This is a hidden file which is a concatenation of the database name and the index name rm .<database name>_<index name> Re-run pgsync pgsync Info If any new tables are added or removed from the schema you should re-run bootstrap before re-running pgsync again.","title":"Re indexing"},{"location":"environment-variables/","text":"PGSync uses the dotenv module for reading a .env file placed at the root of the application. You can place your environment variables in a .env file located at the root of your application. Alternatively, you can also set environment variables manually. e.g $ export PG_USER = kermit-the-frog $ export PG_USER = localhost $ export PG_PORT = 5432 $ export PG_PASSWORD = ****** PGSync provides the following environment variables: Environment variable Default Description SCHEMA Path to the application schema config QUERY_CHUNK_SIZE 10000 Database query chunk size (how many records to fetch at a time) POLL_TIMEOUT 0.1 Poll db interval (consider reducing this duration to increase throughput) ELASTICSEARCH_SCHEME http Elasticsearch protocol ELASTICSEARCH_HOST localhost Elasticsearch host ELASTICSEARCH_PORT 9200 Elasticsearch port ELASTICSEARCH_USER Elasticsearch user ELASTICSEARCH_PASSWORD Elasticsearch password ELASTICSEARCH_TIMEOUT 10 Increase this if you are getting read request timeouts ELASTICSEARCH_CHUNK_SIZE 2000 Elasticsearch index chunk size (how many documents to index at a time) ELASTICSEARCH_VERIFY_CERTS True Verify Elasticsearch SSL certificates PG_HOST localhost Postgres database host PG_USER Postgres database username (superuser) PG_PORT 5432 Postgres database port PG_PASSWORD Postgres database user password REDIS_HOST localhost Redis server host REDIS_PORT 6379 Redis server port REDIS_DB 0 Redis database REDIS_AUTH Postgres database password REDIS_CHUNK_SIZE 1000 Number of items to read from Redis at a time REDIS_SOCKET_TIMEOUT 5 Redis socket connection timeout NEW_RELIC_ENVIRONMENT New Relic environment name NEW_RELIC_APP_NAME New Relic application name NEW_RELIC_LOG_LEVEL Sets the level of detail of messages sent to the log file NEW_RELIC_LICENSE_KEY New Relic license key","title":"Environment variables"},{"location":"features/","text":"Features \u00b6 Key features of PGSync include: Works with any PostgreSQL database (version 9.4 or later). Negligible impact on database performance. Transactionally consistent output in Elasticsearch. This means: writes appear only when they are committed to the database, insert, update and delete operations appear in the same order as they were committed (as opposed to eventual consistency). Fault-tolerant: does not lose data, even if processes crash or a network interruption occurs, etc. The process can be recovered from the last checkpoint. Returns the data directly as Postgres JSON from the database for speed. Supports composite primary and foreign keys. Supports an arbitrary depth of nested entities i.e Tables having long chain of relationship dependencies. Supports Postgres JSON data fields. This means: we can extract JSON fields in a database table as a separate field in the resulting document. Customizable document structure.","title":"Features"},{"location":"features/#features","text":"Key features of PGSync include: Works with any PostgreSQL database (version 9.4 or later). Negligible impact on database performance. Transactionally consistent output in Elasticsearch. This means: writes appear only when they are committed to the database, insert, update and delete operations appear in the same order as they were committed (as opposed to eventual consistency). Fault-tolerant: does not lose data, even if processes crash or a network interruption occurs, etc. The process can be recovered from the last checkpoint. Returns the data directly as Postgres JSON from the database for speed. Supports composite primary and foreign keys. Supports an arbitrary depth of nested entities i.e Tables having long chain of relationship dependencies. Supports Postgres JSON data fields. This means: we can extract JSON fields in a database table as a separate field in the resulting document. Customizable document structure.","title":"Features"},{"location":"getting-started/installation/","text":"$ pip install pgsync ---> 100%","title":"Installation"},{"location":"getting-started/running/","text":"First you need to bootstrap the database. This is a one time operation that: Creates pgsync triggers Creates the logical replication slot bootstrap --config /path/to/schema.json There are two modes of running PGSync daemon mode (runs continously forever) non-daemon mode (runs a single pass and stops) Daemon pgsync --config /optional/path/to/schema.json --daemon Non-daemon pgsync --config /optional/path/to/schema.json Info You can also specify the schema config as an environment variable SCHEMA and omit it in the command(s) above. See the next section on specifying connection parameters via environment variables.","title":"Running"},{"location":"getting-started/setup/","text":"Setup \u00b6 Ensure Postgres database user is a superuser SELECT usename FROM pg_user WHERE usesuper = true Enable logical decoding in postgres.conf wal_level = logical Ensure there is at least one replication slot defined in postgres.conf max_replication_slots = 1","title":"Setup"},{"location":"getting-started/setup/#setup","text":"Ensure Postgres database user is a superuser SELECT usename FROM pg_user WHERE usesuper = true Enable logical decoding in postgres.conf wal_level = logical Ensure there is at least one replication slot defined in postgres.conf max_replication_slots = 1","title":"Setup"},{"location":"schema/","text":"Schema definition file [ { \"database\" : \"<Postgres database name>\" , \"index\" : \"<Elasticsearch index name>\" , \"nodes\" : [ { \"table\" : \"<root table name>\" , \"schema\" : \"<schema name>\" , \"columns\" : [ \"<column 1>\" , \"<column 2>\" , ... ], \"children\" : [ { \"table\" : \"<child table name>\" , \"columns\" : [ \"<column 1>\" , \"<column 2>\" , ... ], \"label\" : \"<document label name>\" , \"relationship\" : { \"variant\" : \"object\" | \"scalar\" , \"type\" : \"one_to_one\" | \"one_to_many\" , \"through_tables\" : [ \"<through table name>\" ] }, \"children\" : [], \"transform\" : { \"rename\" : { \"<old column 1>\" : \"<new column 1>\" , \"<old column 2>\" : \"<new column 2>\" , ... } } }, ... ] } ] } ] Document and node structure: \u00b6 database \u00b6 This is the database name index \u00b6 Optional Elasticsearch index (defaults to database name) table \u00b6 Node table name schema \u00b6 Optional Postgres table schema (defaults to public) label \u00b6 Optional node name in Elasticsearch (defaults to table name) columns \u00b6 Optional list of columns to display. This can be omitted in which case it selects all columns. children \u00b6 Optional list of child nodes if any. This has the same structure as a parent node. relationship \u00b6 Describes the relationship between parent and child. variant \u00b6 variant can be object or scalar object \u00b6 { \"name\" : \"Oxford Press\" , \"id\" : 1 , \"is_active\" : false } scalar \u00b6 [ \"Haruki Murakami\" , \"Philip Gabriel\" ] type \u00b6 type can be one_to_one or one_to_many depending on the relationship type between parent and child through_tables \u00b6 This is the intermediate table that connects the parent to the child transform \u00b6 This allows transforming some node properties. For now, the only operation supported is the rename transform. rename \u00b6 rename a node column \"rename\" : { \"<old column name 1>\" : \"<new column name 1>\" , \"<old column name 2>\" : \"<new column name 2>\" , } Info Changing the schema effectively changes the structure of document in Elasticsearch and this requires re-indexing Elasticsearch. See advanced section on re-indexing on how-to.","title":"Schema definition"},{"location":"schema/#document-and-node-structure","text":"","title":"Document and node structure:"},{"location":"schema/#database","text":"This is the database name","title":"database"},{"location":"schema/#index","text":"Optional Elasticsearch index (defaults to database name)","title":"index"},{"location":"schema/#table","text":"Node table name","title":"table"},{"location":"schema/#schema","text":"Optional Postgres table schema (defaults to public)","title":"schema"},{"location":"schema/#label","text":"Optional node name in Elasticsearch (defaults to table name)","title":"label"},{"location":"schema/#columns","text":"Optional list of columns to display. This can be omitted in which case it selects all columns.","title":"columns"},{"location":"schema/#children","text":"Optional list of child nodes if any. This has the same structure as a parent node.","title":"children"},{"location":"schema/#relationship","text":"Describes the relationship between parent and child.","title":"relationship"},{"location":"schema/#variant","text":"variant can be object or scalar","title":"variant"},{"location":"schema/#object","text":"{ \"name\" : \"Oxford Press\" , \"id\" : 1 , \"is_active\" : false }","title":"object"},{"location":"schema/#scalar","text":"[ \"Haruki Murakami\" , \"Philip Gabriel\" ]","title":"scalar"},{"location":"schema/#type","text":"type can be one_to_one or one_to_many depending on the relationship type between parent and child","title":"type"},{"location":"schema/#through_tables","text":"This is the intermediate table that connects the parent to the child","title":"through_tables"},{"location":"schema/#transform","text":"This allows transforming some node properties. For now, the only operation supported is the rename transform.","title":"transform"},{"location":"schema/#rename","text":"rename a node column \"rename\" : { \"<old column name 1>\" : \"<new column name 1>\" , \"<old column name 2>\" : \"<new column name 2>\" , } Info Changing the schema effectively changes the structure of document in Elasticsearch and this requires re-indexing Elasticsearch. See advanced section on re-indexing on how-to.","title":"rename"},{"location":"tutorial/json-types/","text":"TODO","title":"Json types"},{"location":"tutorial/relationship-with-object-variant/","text":"Each child node can have only one direct parent. We can specify the relationship between a parent and child node with the relationship property. [ { \"database\" : \"book\" , \"index\" : \"book\" , \"nodes\" : [ { \"table\" : \"book\" , \"children\" : [ { \"table\" : \"author\" , \"columns\" : [ \"id\" , \"name\" ], \"relationship\" : { \"variant\" : \"object\" , \"type\" : \"one_to_one\" }, } ] } ] } ] To get this document structure in Elasticsearch [ { \"isbn\" : \"9785811243570\" , \"title\" : \"Charlie and the chocolate factory\" , \"publisher\" : { \"id\" : 1 , \"name\" : \"Oxford Press\" } }, { \"isbn\" : \"9788374950978\" , \"title\" : \"Kafka on the Shore\" , \"publisher\" : { \"id\" : 2 , \"name\" : \"Penguin Books\" } }, { \"isbn\" : \"9781471331435\" , \"title\" : \"1984\" , \"publisher\" : { \"id\" : 3 , \"name\" : \"Pearson Press\" } } ] Info A relationship must define both a variant and a type attribute","title":"Relationship with object variant"},{"location":"tutorial/relationship-with-one-to-many-type/","text":"Each child node can have only one direct parent. We can specify the relationship between a parent and child node with the relationship property. [ { \"database\" : \"book\" , \"index\" : \"book\" , \"nodes\" : [ { \"table\" : \"book\" , \"children\" : [ { \"table\" : \"author\" , \"columns\" : [ \"id\" , \"name\" ], \"relationship\" : { \"variant\" : \"object\" , \"type\" : \"one_to_many\" }, } ] } ] } ] To get this document structure in Elasticsearch [ { \"isbn\" : \"9785811243570\" , \"title\" : \"Charlie and the chocolate factory\" , \"publisher\" : [ { \"id\" : 1 , \"name\" : \"Oxford Press\" } ] }, { \"isbn\" : \"9788374950978\" , \"title\" : \"Kafka on the Shore\" , \"publisher\" : [ { \"id\" : 2 , \"name\" : \"Penguin Books\" } ] }, { \"isbn\" : \"9781471331435\" , \"title\" : \"1984\" , \"publisher\" : [ { \"id\" : 3 , \"name\" : \"Pearson Press\" } ] } ] Info A relationship must define both a variant and a type attribute","title":"Relationship with one to many type"},{"location":"tutorial/relationship-with-one-to-one-type/","text":"Each child node can have only one direct parent. We can specify the relationship between a parent and child node with the relationship property. [ { \"database\" : \"book\" , \"index\" : \"book\" , \"nodes\" : [ { \"table\" : \"book\" , \"children\" : [ { \"table\" : \"author\" , \"columns\" : [ \"id\" , \"name\" ], \"relationship\" : { \"variant\" : \"object\" , \"type\" : \"one_to_one\" }, } ] } ] } ] To get this document structure in Elasticsearch [ { \"isbn\" : \"9785811243570\" , \"title\" : \"Charlie and the chocolate factory\" , \"publisher\" : { \"id\" : 1 , \"name\" : \"Oxford Press\" } }, { \"isbn\" : \"9788374950978\" , \"title\" : \"Kafka on the Shore\" , \"publisher\" : { \"id\" : 2 , \"name\" : \"Penguin Books\" } }, { \"isbn\" : \"9781471331435\" , \"title\" : \"1984\" , \"publisher\" : { \"id\" : 3 , \"name\" : \"Pearson Press\" } } ] Info A relationship must define both a variant and a type attribute","title":"Relationship with one to one type"},{"location":"tutorial/relationship-with-scalar-variant/","text":"Each child node can have only one direct parent. We can specify the relationship between a parent and child node with the relationship property. [ { \"database\" : \"book\" , \"index\" : \"book\" , \"nodes\" : [ { \"table\" : \"book\" , \"children\" : [ { \"table\" : \"author\" , \"columns\" : [ \"name\" ], \"relationship\" : { \"variant\" : \"scalar\" , \"type\" : \"one_to_one\" }, } ] } ] } ] To get this document structure in Elasticsearch [ { \"isbn\" : \"9785811243570\" , \"title\" : \"Charlie and the chocolate factory\" , \"publisher\" : \"Oxford Press\" }, { \"isbn\" : \"9788374950978\" , \"title\" : \"Kafka on the Shore\" , \"publisher\" : \"Penguin Books\" }, { \"isbn\" : \"9781471331435\" , \"title\" : \"1984\" , \"publisher\" : \"Pearson Press\" } ] Info A relationship must define both a variant and a type attribute","title":"Relationship with scalar variant"},{"location":"tutorial/relationship-with-through-tables/","text":"Each child node can have only one direct parent. We can specify the relationship between a parent and child node with the relationship property. [ { \"database\" : \"book\" , \"index\" : \"book\" , \"nodes\" : [ { \"table\" : \"book\" , \"columns\" : [ \"isbn\" , \"title\" , \"description\" ], \"children\" : [ { \"table\" : \"author\" , \"columns\" : [ \"id\" , \"name\" ], \"relationship\" : { \"type\" : \"one_to_many\" , \"variant\" : \"object\" , \"through_tables\" : [ \"book_author\" ] } } ] } ] } ] To get this document structure in Elasticsearch [ { \"isbn\" : \"9785811243570\" , \"title\" : \"Charlie and the chocolate factory\" , \"author\" : [ { \"id\" : 1 , \"name\" : \"Roald Dahl\" } ] }, { \"isbn\" : \"9788374950978\" , \"title\" : \"Kafka on the Shore\" , \"author\" : [ { \"id\" : 2 , \"name\" : \"Haruki Murakami\" }, { \"id\" : 3 , \"name\" : \"Philip Gabriel\" } ] }, { \"isbn\" : \"9781471331435\" , \"title\" : \"1984\" , \"author\" : [ { \"id\" : 4 , \"name\" : \"George Orwell\" } ] } ] Info A relationship must define both a variant and a type attribute","title":"Relationship with through tables"},{"location":"tutorial/selecting-schema/","text":"Postgres supports having multiple schemas in the same database. You can select the schema in the node instead of the default public schema. [ { \"database\" : \"book\" , \"index\" : \"book\" , \"nodes\" : [ { \"table\" : \"book\" , \"schema\" : \"my_book_library\" , \"columns\" : [ \"isbn\" , \"title\" ] } ] } ]","title":"Selecting schema"},{"location":"tutorial/table-with-multiple-children/","text":"What if we added a new table publisher Publisher id (PK) name 1 Oxford Press 2 Penguin Books 3 Pearson Press and we added publisher_id as a foreign key to the Book table: Book isbn (PK) title description publisher_id (FK) 9785811243570 Charlie and the chocolate factory Willy Wonka\u2019s famous chocolate factory is opening at last! 1 9788374950978 Kafka on the Shore Kafka on the Shore is a 2002 novel by Japanese author Haruki Murakami. 2 9781471331435 1984 1984 was George Orwell\u2019s chilling prophecy about the dystopian future. 3 We can simply define this JSON schema where the book table is still the pivot table. [ { \"database\" : \"book\" , \"index\" : \"book\" , \"nodes\" : [ { \"table\" : \"book\" , \"columns\" : [ \"isbn\" , \"title\" , \"description\" ], \"children\" : [ { \"table\" : \"author\" , \"columns\" : [ \"name\" ] }, { \"table\" : \"publisher\" , \"columns\" : [ \"name\" , \"id\" ] } ] } ] } ] To get this document structure in Elasticsearch [ { \"isbn\" : \"9785811243570\" , \"title\" : \"Charlie and the chocolate factory\" , \"description\" : \"Willy Wonka\u2019s famous chocolate factory is opening at last!\" , \"author\" : [ \"Roald Dahl\" ], \"publisher\" : \"Oxford Press\" }, { \"isbn\" : \"9788374950978\" , \"title\" : \"Kafka on the Shore\" , \"description\" : \"Kafka on the Shore is a 2002 novel by Japanese author Haruki Murakami\" , \"author\" : [ \"Haruki Murakami\" , \"Philip Gabriel\" ], \"publisher\" : \"Penguin Books\" }, { \"isbn\" : \"9781471331435\" , \"title\" : \"1984\" , \"description\" : \"1984 was George Orwell\u2019s chilling prophecy about the dystopian future\" , \"author\" : [ \"George Orwell\" ], \"publisher\" : \"Pearson Press\" } ]","title":"Table with multiple children"},{"location":"tutorial/table-with-single-child-node/","text":"Consider this example of a Book library database. Book isbn (PK) title description 9785811243570 Charlie and the chocolate factory Willy Wonka\u2019s famous chocolate factory is opening at last! 9788374950978 Kafka on the Shore Kafka on the Shore is a 2002 novel by Japanese author Haruki Murakami. 9781471331435 1984 1984 was George Orwell\u2019s chilling prophecy about the dystopian future. Author id (PK) name 1 Roald Dahl 2 Haruki Murakami 3 Philip Gabriel 4 George Orwell BookAuthor id (PK) book_isbn (FK) author_id (FK) 1 9785811243570 1 2 9788374950978 2 3 9788374950978 3 4 9781471331435 4 With PGSync, we can simply define this JSON schema where the book table is the pivot. A pivot table indicates the root of your document. { \"table\" : \"book\" , \"columns\" : [ \"isbn\" , \"title\" , \"description\" ], \"children\" : [ { \"table\" : \"author\" , \"columns\" : [ \"name\" ] } ] } To get this document structure in Elasticsearch [ { \"isbn\" : \"9785811243570\" , \"title\" : \"Charlie and the chocolate factory\" , \"description\" : \"Willy Wonka\u2019s famous chocolate factory is opening at last!\" , \"author\" : [ \"Roald Dahl\" ] }, { \"isbn\" : \"9788374950978\" , \"title\" : \"Kafka on the Shore\" , \"description\" : \"Kafka on the Shore is a 2002 novel by Japanese author Haruki Murakami\" , \"author\" : [ \"Haruki Murakami\" , \"Philip Gabriel\" ] }, { \"isbn\" : \"9781471331435\" , \"title\" : \"1984\" , \"description\" : \"1984 was George Orwell\u2019s chilling prophecy about the dystopian future\" , \"author\" : [ \"George Orwell\" ] } ] Behind the scenes, PGSync is generating advanced queries for you such as. SELECT JSON_BUILD_OBJECT ( 'isbn' , book_1 . isbn , 'title' , book_1 . title , 'description' , book_1 . description , 'authors' , anon_1 . authors ) AS \"JSON_BUILD_OBJECT_1\" , book_1 . id FROM book AS book_1 LEFT OUTER JOIN ( SELECT JSON_AGG ( anon_2 . anon ) AS authors , book_author_1 . book_isbn AS book_isbn FROM book_author AS book_author_1 LEFT OUTER JOIN ( SELECT author_1 . name AS anon , author_1 . id AS id FROM author AS author_1 ) AS anon_2 ON anon_2 . id = book_author_1 . author_id GROUP BY book_author_1 . book_isbn ) AS anon_1 ON anon_1 . book_isbn = book_1 . isbn","title":"Table with single child node"},{"location":"tutorial/transform-nodes/","text":"Transform nodes allow changing the output of the document type We can simply define this JSON schema. [ { \"database\" : \"book\" , \"index\" : \"book\" , \"nodes\" : [ { \"table\" : \"book\" , \"columns\" : [ \"isbn\" , \"title\" ], \"transform\" : { \"rename\" : { \"isbn\" : \"book_isbn\" , \"title\" : \"book_title\" } } } ] } ] To get this document structure in Elasticsearch [ { \"book_isbn\" : \"9785811243570\" , \"book_title\" : \"Charlie and the chocolate factory\" }, { \"book_isbn\" : \"9788374950978\" , \"book_title\" : \"Kafka on the Shore\" }, { \"book_isbn\" : \"9781471331435\" , \"book_title\" : \"1984\" } ]","title":"Transform nodes"},{"location":"tutorial/using-labels/","text":"Labels are used to control the output of the document node. We can simply define this JSON schema. [ { \"database\" : \"book\" , \"index\" : \"book\" , \"nodes\" : [ { \"table\" : \"book\" , \"columns\" : [ \"isbn\" , \"title\" ], \"children\" : [ { \"table\" : \"author\" , \"label\" : \"authors\" , \"columns\" : [ \"name\" ] } ] } ] } ] To get this document structure in Elasticsearch [ { \"isbn\" : \"9785811243570\" , \"title\" : \"Charlie and the chocolate factory\" , \"authors\" : [ \"Roald Dahl\" ] }, { \"isbn\" : \"9788374950978\" , \"title\" : \"Kafka on the Shore\" , \"authors\" : [ \"Haruki Murakami\" , \"Philip Gabriel\" ] }, { \"isbn\" : \"9781471331435\" , \"title\" : \"1984\" , \"authors\" : [ \"George Orwell\" ] } ]","title":"Using labels"}]}